# -*- coding: utf-8 -*-
"""Names.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N_JQTd6B7hCL0EbvFfM3XBWULwojWoTP

# Imports
"""

!pip install paddleocr
!python -m pip install paddlepaddle-gpu==2.5.0.post118 -f https://www.paddlepaddle.org.cn/whl/linux/mkl/avx/stable.html

import paddleocr
import paddle
from paddleocr import PaddleOCR
from datetime import datetime
import os
import numpy as np
from PIL import Image
import pandas as pd

from google.colab.patches import cv2_imshow
import cv2

import warnings
warnings.filterwarnings('ignore')

#ocr = PaddleOCR(lang="en", rec_model_type='en', use_gpu=False, rec_algorithm = 'CRNN', rec_image_inverse = False, det_db_thresh=0.4, show_log = True)

from google.colab import drive
drive.mount('/content/drive')

!unzip "/content/drive/MyDrive/OCR-SKU/Box Counting Details.zip"

"""# Code"""

result = ocr.ocr('/content/IMG-20230709-WA0002.jpg')
words = []
for line in result:
    for word_info in line:
        words.append(word_info[1][0])
print(words)

names = ['Amul Pasteurized butter salted', 'Amul Pasteurized butter unsalted', 'Amul Pasteurized table butter', 'Amul White butter Unsalted', 'Amul Pasteurized butter',
         'Amul White butter', 'Amul Butter Tinned', 'Amul pasteurized water buffalo and cow milk butter salted',
         'Amul pasteurized water buffalo and cow milk butter unsalted', 'Infant milk food infant milk substitute']

names = [i.upper() for i in names]
for name in names:
    if 'PASTEURIZED' in name:
        new_name = name.replace('PASTEURIZED', 'PASTEURISED')
        names.append(new_name)

names.append('AMUL BUTTER')
names

entire_text = ' '.join(words).upper()
for i in names:
    if i in entire_text:
        print(i)
        break



path = '/content/Box Counting Details/Amul Powder/1 Amul Spray IMF IMS - 12pc 1kg/'
files = os.listdir(path)
image_paths = [path+i for i in files]

ocr = PaddleOCR(lang="en", rec_model_type='en', use_gpu=False, rec_algorithm = 'CRNN',show_log = False)

def process_image(image_path):
    try:
        result = ocr.ocr(image_path)
        words = []
        for line in result:
            for word_info in line:
                words.append(word_info[1][0])
        return words
    except Exception as e:
        print(e)
        return ['']



import concurrent.futures

t1 = datetime.now()
with concurrent.futures.ThreadPoolExecutor() as executor:
    # Submit the image processing tasks to the executor
    futures = [executor.submit(process_image, image_path) for image_path in image_paths]
    # Collect the results as they become available
    #results = [future.result() for future in concurrent.futures.as_completed(futures)]

    for future in concurrent.futures.as_completed(futures):
        words = future.result()
        entire_text = ' '.join(words).upper()
        got = 0
        print(entire_text)
        for i in names:
            if i in entire_text:
                print(i)
                got = 1
                break
        # if got:
        #     break

t2 = datetime.now()

print(t2-t1)

t1 = datetime.now()
for i in image_paths:
    print(process_image(i))
t2 = datetime.now()
print(t2-t1)



import multiprocessing

def process_batch(image_paths):
    with multiprocessing.Pool(processes=4) as pool:
        results = pool.map(process_image, image_paths)
    return results

t1 = datetime.now()
# Example usage
batch_results = process_batch(image_paths)
t2 = datetime.now()

print(t2-t1)

# Print the results
for result in batch_results:
    print(result)

#mutual funds, health insurance,
# mobile-> 1500, books, clothing, travel
#

# 55k ->